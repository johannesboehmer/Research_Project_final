#
# Phase 2/3: Delay Tiebreaker Performance Comparison
# Compares QueueGPSR (delay-aware) vs standard INET GPSR under congestion
#
# SPDX-License-Identifier: LGPL-3.0-or-later
#

[General]
network = DelayTiebreakerNetwork
sim-time-limit = 300s
result-dir = ../../results/delay_tiebreaker

# Random number generation (match baseline for reproducibility)
num-rngs = 3
repeat = 1
**.mobility.rng-0 = 1
**.wlan[*].mac.rng-0 = 2

# Network size
*.numHosts = 20

# Radio medium
*.radioMedium.transmissionRange = 300m
*.radioMedium.interferenceRange = 0m
*.radioMedium.communicationRange = 300m

# Force single wireless interface
*.host[*].numWlanInterfaces = 1
*.host[*].wlan[0].typename = "AckingWirelessInterface"

# UnitDisk radio for deterministic connectivity (Phase 2)
*.host[*].wlan[*].bitrate = 1Mbps  # CONGESTED: 50% of baseline
*.host[*].wlan[*].mac.headerLength = 23B
*.host[*].wlan[*].radio.typename = "UnitDiskRadio"
*.host[*].wlan[*].radio.transmitter.headerLength = 96b
*.host[*].wlan[*].radio.transmitter.communicationRange = 300m
*.host[*].wlan[*].radio.transmitter.interferenceRange = 0m
*.host[*].wlan[*].radio.transmitter.detectionRange = 0m
*.host[*].wlan[*].radio.receiver.ignoreInterference = true

# Mobility constraints
*.host[*].mobility.constraintAreaMinX = 0m
*.host[*].mobility.constraintAreaMinY = 0m
*.host[*].mobility.constraintAreaMaxX = 1400m
*.host[*].mobility.constraintAreaMaxY = 1200m
*.host[*].mobility.constraintAreaMinZ = 0m
*.host[*].mobility.constraintAreaMaxZ = 0m
*.host[*].mobility.typename = "StationaryMobility"
*.host[*].mobility.initFromDisplayString = false

# QueueGPSR routing parameters (using queueGpsr submodule)
*.host[*].hasStatus = false
*.host[*].forwarding = true
# Note: QueueGpsrRouter already has queueGpsr submodule, don't override typename
# *.host[*].routing.typename = "QueueGpsr"  # WRONG - this creates a separate routing module
*.host[*].queueGpsr.beaconInterval = 5s
*.host[*].queueGpsr.neighborValidityInterval = 20s
*.host[*].queueGpsr.displayBubbles = false

# Grid positioning: 5x4 grid, 250m spacing (match baseline exactly)
# Row 0 (bottom)
*.host[0].mobility.initialX = 100m
*.host[0].mobility.initialY = 100m
*.host[1].mobility.initialX = 350m
*.host[1].mobility.initialY = 100m
*.host[2].mobility.initialX = 600m
*.host[2].mobility.initialY = 100m
*.host[3].mobility.initialX = 850m
*.host[3].mobility.initialY = 100m
*.host[4].mobility.initialX = 1100m
*.host[4].mobility.initialY = 100m

# Row 1
*.host[5].mobility.initialX = 100m
*.host[5].mobility.initialY = 350m
*.host[6].mobility.initialX = 350m
*.host[6].mobility.initialY = 350m
*.host[7].mobility.initialX = 600m
*.host[7].mobility.initialY = 350m
*.host[8].mobility.initialX = 850m
*.host[8].mobility.initialY = 350m
*.host[9].mobility.initialX = 1100m
*.host[9].mobility.initialY = 350m

# Row 2
*.host[10].mobility.initialX = 100m
*.host[10].mobility.initialY = 600m
*.host[11].mobility.initialX = 350m
*.host[11].mobility.initialY = 600m
*.host[12].mobility.initialX = 600m
*.host[12].mobility.initialY = 600m
*.host[13].mobility.initialX = 850m
*.host[13].mobility.initialY = 600m
*.host[14].mobility.initialX = 1100m
*.host[14].mobility.initialY = 600m

# Row 3 (top)
*.host[15].mobility.initialX = 100m
*.host[15].mobility.initialY = 850m
*.host[16].mobility.initialX = 350m
*.host[16].mobility.initialY = 850m
*.host[17].mobility.initialX = 600m
*.host[17].mobility.initialY = 850m
*.host[18].mobility.initialX = 850m
*.host[18].mobility.initialY = 850m
*.host[19].mobility.initialX = 1100m
*.host[19].mobility.initialY = 850m

# Initial Z coordinate
*.host[*].mobility.initialZ = 0m

# IPv4 configurator
*.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/></config>")

# Applications (default: no apps)
*.host[*].numApps = 0

#=============================================================================
# Config: CongestedDelayTiebreakerDisabled
# Baseline: QueueGPSR with delay tiebreaker DISABLED (matches standard GPSR)
#=============================================================================

[Config CongestedDelayTiebreakerDisabled]
description = "QueueGPSR without delay tiebreaker (baseline for comparison)"

# Disable delay tiebreaker (standard GPSR behavior)
*.host[*].queueGpsr.enableDelayTiebreaker = false

# Cross-traffic flow 1: host[0] -> host[19] (bottom-left to top-right)
*.host[0].numApps = 1
*.host[0].app[0].typename = "UdpBasicApp"
*.host[0].app[0].destAddresses = "host[19]"
*.host[0].app[0].destPort = 5000
*.host[0].app[0].messageLength = 1024B  # CONGESTED: 2x packet size
*.host[0].app[0].sendInterval = exponential(0.5s)  # CONGESTED: 2x rate
*.host[0].app[0].startTime = uniform(0s, 5s)
*.host[0].app[0].stopTime = this.startTime + 295s

*.host[19].numApps = 1
*.host[19].app[0].typename = "UdpSink"
*.host[19].app[0].localPort = 5000

# Cross-traffic flow 2: host[4] -> host[15] (bottom-right to top-left)
*.host[4].numApps = 1
*.host[4].app[0].typename = "UdpBasicApp"
*.host[4].app[0].destAddresses = "host[15]"
*.host[4].app[0].destPort = 5001
*.host[4].app[0].messageLength = 1024B
*.host[4].app[0].sendInterval = exponential(0.5s)
*.host[4].app[0].startTime = uniform(0s, 5s)
*.host[4].app[0].stopTime = this.startTime + 295s

*.host[15].numApps = 1
*.host[15].app[0].typename = "UdpSink"
*.host[15].app[0].localPort = 5001

#=============================================================================
# Config: CongestedDelayTiebreakerEnabled
# Test: QueueGPSR with delay tiebreaker ENABLED
#=============================================================================

[Config CongestedDelayTiebreakerEnabled]
description = "QueueGPSR with delay-aware tiebreaker (experimental)"
extends = CongestedDelayTiebreakerDisabled

# Enable delay tiebreaker (Phase 2: distance-based delay)
*.host[*].queueGpsr.enableDelayTiebreaker = true
*.host[*].queueGpsr.distanceEqualityThreshold = 1.0m
*.host[*].queueGpsr.delayEstimationFactor = 0.001s  # 1ms per meter (Phase 2 simulation)

# Enable queue-aware delay (Phase 3: L_queue = Q/R)
*.host[*].queueGpsr.enableQueueDelay = true

#=============================================================================
# Config: SanityTest
# Quick 180s test to verify network formation and routing
#=============================================================================

[Config SanityTest]
description = "180s sanity test for delay tiebreaker mechanism"
extends = CongestedDelayTiebreakerEnabled
sim-time-limit = 180s

#=============================================================================
# Config: LargeTiebandEnabled
# Increase distance threshold to provoke tiebreaker activations
#=============================================================================

[Config LargeTiebandEnabled]
description = "QueueGPSR with large tiebreaker band (50m threshold)"
extends = CongestedDelayTiebreakerDisabled

# Enable delay tiebreaker with LARGE threshold
*.host[*].queueGpsr.enableDelayTiebreaker = true
*.host[*].queueGpsr.distanceEqualityThreshold = 50m  # Large band to catch more ties
*.host[*].queueGpsr.delayEstimationFactor = 0.001s

#=============================================================================
# Config: RandomPlacementEnabled
# Random node placement to create equidistant scenarios
#=============================================================================

[Config RandomPlacementEnabled]
description = "Random placement with delay tiebreaker to provoke activations"

# General settings
sim-time-limit = 300s
result-dir = ../../results/delay_tiebreaker
num-rngs = 3
repeat = 1
**.mobility.rng-0 = 1
**.wlan[*].mac.rng-0 = 2

# Network size
*.numHosts = 20

# Radio medium
*.radioMedium.transmissionRange = 300m
*.radioMedium.interferenceRange = 0m
*.radioMedium.communicationRange = 300m

# Wireless interface
*.host[*].numWlanInterfaces = 1
*.host[*].wlan[0].typename = "AckingWirelessInterface"
*.host[*].wlan[*].bitrate = 1Mbps
*.host[*].wlan[*].mac.headerLength = 23B
*.host[*].wlan[*].radio.typename = "UnitDiskRadio"
*.host[*].wlan[*].radio.transmitter.headerLength = 96b
*.host[*].wlan[*].radio.transmitter.communicationRange = 300m
*.host[*].wlan[*].radio.transmitter.interferenceRange = 0m
*.host[*].wlan[*].radio.transmitter.detectionRange = 0m
*.host[*].wlan[*].radio.receiver.ignoreInterference = true

# RANDOM mobility (not grid!)
*.host[*].mobility.typename = "StationaryMobility"
*.host[*].mobility.initFromDisplayString = false
*.host[*].mobility.constraintAreaMinX = 0m
*.host[*].mobility.constraintAreaMinY = 0m
*.host[*].mobility.constraintAreaMaxX = 1400m
*.host[*].mobility.constraintAreaMaxY = 1200m
*.host[*].mobility.constraintAreaMinZ = 0m
*.host[*].mobility.constraintAreaMaxZ = 0m

# Random placement (provokes equidistant scenarios)
*.host[*].mobility.initialX = uniform(0m, 1400m)
*.host[*].mobility.initialY = uniform(0m, 1200m)
*.host[*].mobility.initialZ = 0m

# QueueGPSR routing with delay tiebreaker
*.host[*].hasStatus = false
*.host[*].forwarding = true
*.host[*].queueGpsr.beaconInterval = 5s
*.host[*].queueGpsr.neighborValidityInterval = 20s
*.host[*].queueGpsr.displayBubbles = false
*.host[*].queueGpsr.enableDelayTiebreaker = true
*.host[*].queueGpsr.distanceEqualityThreshold = 100m  # Very large threshold to provoke ties
*.host[*].queueGpsr.delayEstimationFactor = 0.001s

# Configurator
*.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/></config>")

# Applications
*.host[*].numApps = 0

# Cross-traffic flows (use first and last hosts)
*.host[0].numApps = 1
*.host[0].app[0].typename = "UdpBasicApp"
*.host[0].app[0].destAddresses = "host[19]"
*.host[0].app[0].destPort = 5000
*.host[0].app[0].messageLength = 1024B
*.host[0].app[0].sendInterval = exponential(0.5s)
*.host[0].app[0].startTime = uniform(0s, 5s)
*.host[0].app[0].stopTime = this.startTime + 295s

*.host[19].numApps = 1
*.host[19].app[0].typename = "UdpSink"
*.host[19].app[0].localPort = 5000

*.host[4].numApps = 1
*.host[4].app[0].typename = "UdpBasicApp"
*.host[4].app[0].destAddresses = "host[15]"
*.host[4].app[0].destPort = 5001
*.host[4].app[0].messageLength = 1024B
*.host[4].app[0].sendInterval = exponential(0.5s)
*.host[4].app[0].startTime = uniform(0s, 5s)
*.host[4].app[0].stopTime = this.startTime + 295s

*.host[15].numApps = 1
*.host[15].app[0].typename = "UdpSink"
*.host[15].app[0].localPort = 5001


#
# SyntheticTieTest: Forced equidistant scenario to test tiebreaker activation
#
[Config SyntheticTieTest]
network = TiebreakerTestNetwork
sim-time-limit = 120s
*.numHosts = 5

# Radio medium - very large range to ensure connectivity
*.radioMedium.transmissionRange = 1000m
*.radioMedium.interferenceRange = 0m
*.radioMedium.communicationRange = 1000m

# Force single wireless interface
*.host[*].numWlanInterfaces = 1
*.host[*].wlan[0].typename = "AckingWirelessInterface"
*.host[*].wlan[0].radio.transmitter.bitrate = 1Mbps

# QueueGPSR configuration with large threshold
*.host[*].queueGpsr.beaconInterval = 10s
*.host[*].queueGpsr.neighborValidityInterval = 30s
*.host[*].queueGpsr.displayBubbles = false
*.host[*].queueGpsr.enableDelayTiebreaker = true
*.host[*].queueGpsr.distanceEqualityThreshold = 50m
*.host[*].queueGpsr.delayEstimationFactor = 0.005s  # 5ms per meter (needs 's' unit)

# Static positions designed to create a tie:
# host[0] = source at (100, 500)
# host[1] = neighbor A at (400, 550)  - distance to dest = sqrt((600-400)^2 + (500-550)^2) = sqrt(40000+2500) = 206.16m
# host[2] = neighbor B at (400, 450)  - distance to dest = sqrt((600-400)^2 + (500-450)^2) = sqrt(40000+2500) = 206.16m
# host[3] = destination at (600, 500)
# host[4] = extra node (not used)
*.host[*].mobility.typename = "StationaryMobility"
*.host[0].mobility.initialX = 100m
*.host[0].mobility.initialY = 500m
*.host[0].mobility.initialZ = 0m

*.host[1].mobility.initialX = 400m
*.host[1].mobility.initialY = 550m
*.host[1].mobility.initialZ = 0m

*.host[2].mobility.initialX = 400m
*.host[2].mobility.initialY = 450m
*.host[2].mobility.initialZ = 0m

*.host[3].mobility.initialX = 600m
*.host[3].mobility.initialY = 500m
*.host[3].mobility.initialZ = 0m

*.host[4].mobility.initialX = 100m
*.host[4].mobility.initialY = 100m
*.host[4].mobility.initialZ = 0m

# Single UDP flow from host[0] to host[3]
*.host[0].numApps = 1
*.host[0].app[0].typename = "UdpBasicApp"
*.host[0].app[0].destAddresses = "host[3]"
*.host[0].app[0].destPort = 6000
*.host[0].app[0].messageLength = 512B
*.host[0].app[0].sendInterval = 1s
*.host[0].app[0].startTime = 30s  # Wait longer for neighbor discovery (2-3 beacon intervals)
*.host[0].app[0].stopTime = 110s

*.host[3].numApps = 1
*.host[3].app[0].typename = "UdpSink"
*.host[3].app[0].localPort = 6000

# Disable apps on other hosts
*.host[1].numApps = 0
*.host[2].numApps = 0
*.host[4].numApps = 0

#=============================================================================
# Config: CongestedQueueAwareOff
# HIGH CONGESTION BASELINE: Queue-aware OFF (distance-only delay estimation)
# Purpose: Baseline for comparing queue-aware impact under heavy traffic
#=============================================================================

[Config CongestedQueueAwareOff]
description = "Heavy congestion baseline - queue-aware OFF (distance-only)"
extends = CongestedDelayTiebreakerDisabled

# Lower bitrate to force congestion (1 Mbps from General already set)
# Note: General section already has *.host[*].wlan[*].bitrate = 1Mbps

# HIGH TRAFFIC: Increase rate to saturate 1 Mbps link
# Cross-traffic flow 1: host[0] -> host[19] (bottom-left to top-right)
*.host[0].numApps = 1
*.host[0].app[0].typename = "UdpBasicApp"
*.host[0].app[0].destAddresses = "host[19]"
*.host[0].app[0].destPort = 5000
*.host[0].app[0].messageLength = 512B  # Smaller packets for 1 Mbps link
*.host[0].app[0].sendInterval = exponential(0.05s)  # 20 pkt/s = 81.92 kbps
*.host[0].app[0].startTime = uniform(0s, 5s)
*.host[0].app[0].stopTime = this.startTime + 295s

*.host[19].numApps = 1
*.host[19].app[0].typename = "UdpSink"
*.host[19].app[0].localPort = 5000

# Cross-traffic flow 2: host[4] -> host[15] (bottom-right to top-left)
*.host[4].numApps = 1
*.host[4].app[0].typename = "UdpBasicApp"
*.host[4].app[0].destAddresses = "host[15]"
*.host[4].app[0].destPort = 5001
*.host[4].app[0].messageLength = 512B
*.host[4].app[0].sendInterval = exponential(0.05s)  # 20 pkt/s = 81.92 kbps
*.host[4].app[0].startTime = uniform(0s, 5s)
*.host[4].app[0].stopTime = this.startTime + 295s

*.host[15].numApps = 1
*.host[15].app[0].typename = "UdpSink"
*.host[15].app[0].localPort = 5001

# Additional flows to saturate intermediate hops
# Flow 3: host[10] -> host[9] (middle of network)
*.host[10].numApps = 1
*.host[10].app[0].typename = "UdpBasicApp"
*.host[10].app[0].destAddresses = "host[9]"
*.host[10].app[0].destPort = 5002
*.host[10].app[0].messageLength = 512B
*.host[10].app[0].sendInterval = exponential(0.05s)  # 20 pkt/s
*.host[10].app[0].startTime = uniform(0s, 5s)
*.host[10].app[0].stopTime = this.startTime + 295s

*.host[9].numApps = 1
*.host[9].app[0].typename = "UdpSink"
*.host[9].app[0].localPort = 5002

# Flow 4: host[5] -> host[14] (cross-traffic)
*.host[5].numApps = 1
*.host[5].app[0].typename = "UdpBasicApp"
*.host[5].app[0].destAddresses = "host[14]"
*.host[5].app[0].destPort = 5003
*.host[5].app[0].messageLength = 512B
*.host[5].app[0].sendInterval = exponential(0.05s)  # 20 pkt/s
*.host[5].app[0].startTime = uniform(0s, 5s)
*.host[5].app[0].stopTime = this.startTime + 295s

*.host[14].numApps = 1
*.host[14].app[0].typename = "UdpSink"
*.host[14].app[0].localPort = 5003

# Delay tiebreaker OFF (distance-only)
*.host[*].queueGpsr.enableDelayTiebreaker = true
*.host[*].queueGpsr.distanceEqualityThreshold = 50m  # Large threshold to catch ties
*.host[*].queueGpsr.delayEstimationFactor = 0.001s
*.host[*].queueGpsr.enableQueueDelay = false  # OFF: no queue term in delay

#=============================================================================
# Config: CongestedQueueAwareOn
# HIGH CONGESTION WITH QUEUE-AWARE: Queue-aware ON
# Purpose: Test if queue-aware routing reduces delay under heavy traffic
#=============================================================================

[Config CongestedQueueAwareOn]
description = "Heavy congestion with queue-aware routing - queue-aware ON"
extends = CongestedQueueAwareOff

# Enable queue-aware delay estimation (Phase 3)
*.host[*].queueGpsr.enableQueueDelay = true  # ON: adds Q/R term to delay

#=============================================================================
# Config: MicroDiamondTest
# DECISION FLIP PROOF: 4-node diamond with guaranteed two GPSR-forward candidates
# Purpose: Prove queue-aware tiebreaker selects less-congested path
# ENHANCED: Staggered beacons, extended preload, reduced rate during beacon windows
#=============================================================================

[Config MicroDiamondTest]
description = "DECISION FLIP PROOF: Micro diamond with differential congestion"
network = DelayTiebreakerNetwork
sim-time-limit = 90s  # Extended for delayed flow start
result-dir = ../../results/delay_tiebreaker

*.numHosts = 4

# Radio medium - reduced range for closer topology
*.radioMedium.transmissionRange = 250m
*.radioMedium.interferenceRange = 0m
*.radioMedium.communicationRange = 250m

# Wireless interface
*.host[*].numWlanInterfaces = 1
*.host[*].wlan[0].typename = "AckingWirelessInterface"
*.host[*].wlan[*].bitrate = 2Mbps  # 2Mbps for reliable transmission
*.host[*].wlan[*].mac.headerLength = 23B
*.host[*].wlan[*].radio.typename = "UnitDiskRadio"
*.host[*].wlan[*].radio.transmitter.headerLength = 96b
*.host[*].wlan[*].radio.transmitter.communicationRange = 250m
*.host[*].wlan[*].radio.transmitter.interferenceRange = 0m
*.host[*].wlan[*].radio.transmitter.detectionRange = 0m
*.host[*].wlan[*].radio.receiver.ignoreInterference = true

# Mobility
*.host[*].mobility.typename = "StationaryMobility"
*.host[*].mobility.initFromDisplayString = false

# Diamond topology: CLOSER relays at 200m from source (was 300m)
# Distance calculation: both relays exactly 200m from source
# sqrt(100^2 + 173.2^2) = 200m
*.host[0].mobility.initialX = 100m      # Source (center bottom)
*.host[0].mobility.initialY = 0m
*.host[0].mobility.initialZ = 0m

*.host[1].mobility.initialX = 0m        # Relay A (left) - will be IDLE
*.host[1].mobility.initialY = 173.2m   # sqrt(200^2 - 100^2) = 173.2m
*.host[1].mobility.initialZ = 0m

*.host[2].mobility.initialX = 200m      # Relay B (right) - will be CONGESTED
*.host[2].mobility.initialY = 173.2m
*.host[2].mobility.initialZ = 0m

*.host[3].mobility.initialX = 100m      # Dest (center top)
*.host[3].mobility.initialY = 346.4m   # 2 * 173.2m
*.host[3].mobility.initialZ = 0m

# IPv4 configurator
*.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/></config>")

# QueueGpsr parameters - FAST BEACONS for neighbor discovery
*.host[*].queueGpsr.beaconInterval = 2s  # 2s base interval
*.host[*].queueGpsr.neighborValidityInterval = 20s
*.host[*].queueGpsr.enableDelayTiebreaker = true
*.host[*].queueGpsr.distanceEqualityThreshold = 50m  # Relays are exactly 200m, within threshold
*.host[*].queueGpsr.delayEstimationFactor = 0.001s
*.host[*].queueGpsr.enableQueueDelay = true  # CRITICAL: queue-aware ON
*.host[*].queueGpsr.displayBubbles = false

# PRELOAD Relay B EXTENDED through decision window - INCREASED RATE to saturate 2 Mbps link
*.host[2].numApps = 1
*.host[2].app[0].typename = "UdpBasicApp"
*.host[2].app[0].destAddresses = "host[3]"
*.host[2].app[0].destPort = 6000
*.host[2].app[0].messageLength = 1024B  
*.host[2].app[0].sendInterval = 0.0036s  # 278 pkt/s = 2.28 Mbps (oversaturates 2 Mbps link)
*.host[2].app[0].startTime = 0s
*.host[2].app[0].stopTime = 80s  # EXTENDED: Continue through entire test

# Main test flow: Source → Dest (start at 65s AFTER beacons stabilize)
*.host[0].numApps = 1
*.host[0].app[0].typename = "UdpBasicApp"
*.host[0].app[0].destAddresses = "host[3]"
*.host[0].app[0].destPort = 6001
*.host[0].app[0].messageLength = 500B
*.host[0].app[0].sendInterval = 0.1s  # 10 pkt/s
*.host[0].app[0].startTime = 65s  # DELAYED: Start after beacons stabilize (~61s observed)
*.host[0].app[0].stopTime = 85s

# Destination sinks
*.host[3].numApps = 2
*.host[3].app[0].typename = "UdpSink"
*.host[3].app[0].localPort = 6000
*.host[3].app[1].typename = "UdpSink"
*.host[3].app[1].localPort = 6001

# Relay A stays idle (no apps)
*.host[1].numApps = 0

#=============================================================================
# HEXAGONAL TIE TEST - Guaranteed Equidistant Geometry
#=============================================================================

[Config HexagonalTieTest]
description = "HEXAGONAL: Perfect equidistant relays for guaranteed tie detection"
network = DelayTiebreakerNetwork
sim-time-limit = 40s
result-dir = ../../results/delay_tiebreaker

*.numHosts = 4

# Radio medium - EXTENDED range to ensure connectivity
*.radioMedium.transmissionRange = 300m
*.radioMedium.interferenceRange = 0m
*.radioMedium.communicationRange = 300m

# Wireless interface
*.host[*].numWlanInterfaces = 1
*.host[*].wlan[0].typename = "AckingWirelessInterface"
*.host[*].wlan[*].bitrate = 2Mbps
*.host[*].wlan[*].mac.headerLength = 23B
*.host[*].wlan[*].radio.typename = "UnitDiskRadio"
*.host[*].wlan[*].radio.transmitter.headerLength = 96b
*.host[*].wlan[*].radio.transmitter.communicationRange = 300m
*.host[*].wlan[*].radio.transmitter.interferenceRange = 0m
*.host[*].wlan[*].radio.transmitter.detectionRange = 0m
*.host[*].wlan[*].radio.receiver.ignoreInterference = true

# Mobility - HEXAGONAL topology with 60° symmetry
*.host[*].mobility.typename = "StationaryMobility"
*.host[*].mobility.initFromDisplayString = false

# Hexagonal coordinates for PERFECT equidistance
# Source at (0, 200), Dest at (300, 200) - horizontal line at Y=200
# Both relays at X=150 with Y offsets creating symmetric angles
# Distance from each relay to dest = sqrt(150^2 + 130^2) ≈ 199.2m (EQUIDISTANT)
*.host[0].mobility.initialX = 0m        # Source
*.host[0].mobility.initialY = 200m
*.host[0].mobility.initialZ = 0m

*.host[1].mobility.initialX = 150m      # Relay A: above horizontal line - IDLE
*.host[1].mobility.initialY = 330m      # 200 + 130 = 330m
*.host[1].mobility.initialZ = 0m

*.host[2].mobility.initialX = 150m      # Relay B: below horizontal line - CONGESTED  
*.host[2].mobility.initialY = 70m       # 200 - 130 = 70m (symmetric to Relay A)
*.host[2].mobility.initialZ = 0m

*.host[3].mobility.initialX = 450m      # Destination - beyond source's 300m range
*.host[3].mobility.initialY = 200m      # Forces routing through relays
*.host[3].mobility.initialZ = 0m

# IPv4 configurator
*.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/></config>")

# QueueGpsr parameters - WIDE threshold to catch any near-ties
*.host[*].queueGpsr.beaconInterval = 2s
*.host[*].queueGpsr.neighborValidityInterval = 30s  # Extended validity
*.host[*].queueGpsr.enableDelayTiebreaker = true
*.host[*].queueGpsr.distanceEqualityThreshold = 10m  # Tight threshold (relays are EXACTLY equidistant)
*.host[*].queueGpsr.delayEstimationFactor = 0.001s
*.host[*].queueGpsr.enableQueueDelay = true
*.host[*].queueGpsr.displayBubbles = false

# PRELOAD Relay B with HEAVY congestion to saturate 2 Mbps link
# START AFTER beacons propagate to avoid interference with neighbor discovery
*.host[2].numApps = 1
*.host[2].app[0].typename = "UdpBasicApp"
*.host[2].app[0].destAddresses = "host[3]"
*.host[2].app[0].destPort = 6000
*.host[2].app[0].messageLength = 1024B  
*.host[2].app[0].sendInterval = 0.0036s  # 278 pkt/s = 2.28 Mbps (SATURATES 2 Mbps link)
*.host[2].app[0].startTime = 6s  # DELAYED: Start after beacons propagate (3 beacon intervals)
*.host[2].app[0].stopTime = 35s

# Main test flow: Source → Dest (start at 10s after beacons propagate)
*.host[0].numApps = 1
*.host[0].app[0].typename = "UdpBasicApp"
*.host[0].app[0].destAddresses = "host[3]"
*.host[0].app[0].destPort = 6001
*.host[0].app[0].messageLength = 500B
*.host[0].app[0].sendInterval = 0.1s  # 10 pkt/s
*.host[0].app[0].startTime = 10s  # Start after 5 beacon intervals (2s * 5 = 10s)
*.host[0].app[0].stopTime = 35s

# Destination sinks
*.host[3].numApps = 2
*.host[3].app[0].typename = "UdpSink"
*.host[3].app[0].localPort = 6000
*.host[3].app[1].typename = "UdpSink"
*.host[3].app[1].localPort = 6001

# Relay A stays idle
*.host[1].numApps = 0

