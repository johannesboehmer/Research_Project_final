#
# Queue-Aware GPSR Tiebreaker - Validation Test
# Demonstrates queue-aware routing decisions when GPSR candidates are equidistant
#
# SPDX-License-Identifier: LGPL-3.0-or-later
#

[General]
network = DelayTiebreakerNetwork
result-dir = ../../results/delay_tiebreaker

#=============================================================================
# VALIDATION TEST: Hexagonal Topology with Differential Congestion
#=============================================================================

[Config QueueAwareTiebreakerValidation]
description = "Queue-aware tiebreaker validation: idle relay selected over congested relay"
sim-time-limit = 40s

# Network topology: 4 nodes (source, 2 relays, destination)
*.numHosts = 4

# Radio medium configuration - IEEE 802.11 Scalar (realistic MAC/PHY)
# No medium-level configuration needed (uses defaults)

# Wireless interface - IEEE 802.11 with realistic CSMA/CA
*.host[*].numWlanInterfaces = 1
*.host[*].wlan[0].typename = "Ieee80211Interface"
*.host[*].wlan[*].bitrate = 2Mbps
*.host[*].wlan[*].mac.typename = "Ieee80211Mac"
*.host[*].wlan[*].mac.dcf.channelAccess.cwMin = 15
*.host[*].wlan[*].mac.dcf.channelAccess.cwMax = 1023
*.host[*].wlan[*].radio.typename = "Ieee80211ScalarRadio"
*.host[*].wlan[*].radio.transmitter.power = 20mW  # INCREASED to ensure all nodes can exchange beacons
*.host[*].wlan[*].radio.transmitter.bitrate = 2Mbps

# Priority queue configuration: 2 queues (control vs data)
# Queue 0 = data traffic (bulk UDP, ARP, etc.)
# Queue 1 = control traffic (GPSR beacons)
*.host[*].wlan[*].mac.tx.queue.typename = "PriorityQueue"
*.host[*].wlan[*].mac.tx.queue.numQueues = 2
*.host[*].wlan[*].mac.tx.queue.classifier.typename = "ContentBasedClassifier"
*.host[*].wlan[*].mac.tx.queue.classifier.packetFilters = ["GPSRBeacon", "*"]
*.host[*].wlan[*].mac.dcf.originatorMacDataService.sequenceNumberAssignment.typename = "QosSequenceNumberAssignment"
  # Beacons → queue 1 (high priority), everything else → queue 0

# Stationary positions - HEXAGONAL layout for perfect equidistance
*.host[*].mobility.typename = "StationaryMobility"
*.host[*].mobility.initFromDisplayString = false

# Node positions:
# - Source at origin (0, 200)
# - Relay A at (150, 330) - CONGESTED with background traffic
# - Relay B at (150, 70) - IDLE, no background traffic
# - Destination at (450, 200) - Beyond source's 300m range, forces routing through relays
# 
# Both relays are exactly 326.956m from destination (perfectly equidistant)
*.host[0].mobility.initialX = 0m        # Source
*.host[0].mobility.initialY = 200m
*.host[0].mobility.initialZ = 0m

*.host[1].mobility.initialX = 150m      # Relay A - CONGESTED
*.host[1].mobility.initialY = 330m
*.host[1].mobility.initialZ = 0m

*.host[2].mobility.initialX = 150m      # Relay B - IDLE
*.host[2].mobility.initialY = 70m
*.host[2].mobility.initialZ = 0m

*.host[3].mobility.initialX = 450m      # Destination
*.host[3].mobility.initialY = 200m
*.host[3].mobility.initialZ = 0m

# IP address configuration
*.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/></config>")

# Routing protocol - use QueueGpsr via standard INET routing interface
*.host[*].routing.typename = "researchproject.routing.queuegpsr.QueueGpsr"

# QueueGpsr routing parameters - ENABLE queue-aware tiebreaker
*.host[*].routing.beaconInterval = 2s
*.host[*].routing.neighborValidityInterval = 30s
*.host[*].routing.enableDelayTiebreaker = true              # ENABLE tiebreaker
*.host[*].routing.distanceEqualityThreshold = 10m            # Tight threshold for validation
*.host[*].routing.delayEstimationFactor = 0.001s
*.host[*].routing.enableQueueDelay = true                   # RE-ENABLED with UDP/IP-level measurement
*.host[*].routing.displayBubbles = false

# Required module paths for MANET routing
*.host[*].routing.interfaceTableModule = "^.interfaceTable"
*.host[*].routing.routingTableModule = "^.ipv4.routingTable"
*.host[*].routing.networkProtocolModule = "^.ipv4.ip"
*.host[*].routing.outputInterface = "wlan0"

# Background congestion on Relay A (host[1])
# Moderate congestion: 183 pkt/s × 1024B = 1.50 Mbps (75% of 2 Mbps link)
# Creates measurable queue buildup for tiebreaker activation
# Starts at t=6s (after beacon propagation) to ensure neighbor discovery
*.host[1].numApps = 1
*.host[1].app[0].typename = "UdpBasicApp"
*.host[1].app[0].destAddresses = "host[3]"
*.host[1].app[0].destPort = 6000
*.host[1].app[0].messageLength = 1024B
# *.host[1].app[0].sendInterval = 0.005s   # 183 pkt/s = 1.50 Mbps

# *.host[1].app[0].sendInterval = 0.00546s   # 183 pkt/s = 1.50 Mbps
*.host[1].app[0].sendInterval = 0.005s
*.host[1].app[0].startTime = 6s              # Delayed start
*.host[1].app[0].stopTime = 35s

# Main test flow: Source → Destination
# Starts at t=10s after neighbor discovery and congestion buildup
*.host[0].numApps = 1
*.host[0].app[0].typename = "UdpBasicApp"
*.host[0].app[0].destAddresses = "host[3]"
*.host[0].app[0].destPort = 6001
*.host[0].app[0].messageLength = 500B
*.host[0].app[0].sendInterval = 0.1s          # 10 pkt/s test flow
*.host[0].app[0].startTime = 10s
*.host[0].app[0].stopTime = 35s

# Destination sink applications
*.host[3].numApps = 2
*.host[3].app[0].typename = "UdpSink"
*.host[3].app[0].localPort = 6000
*.host[3].app[1].typename = "UdpSink"
*.host[3].app[1].localPort = 6001

# Relay B stays idle (no applications)
*.host[2].numApps = 0

#=============================================================================
# BASELINE COMPARISON: Tiebreaker disabled (standard GPSR behavior)
#=============================================================================

[Config QueueAwareTiebreakerDisabled]
extends = QueueAwareTiebreakerValidation
description = "Baseline: tiebreaker disabled, random relay selection"

# Disable queue-aware tiebreaker (standard GPSR)
*.host[*].routing.enableDelayTiebreaker = false

#=============================================================================
# MULTI-HOP PERFORMANCE COMPARISON: Force relay usage for measurable impact
#=============================================================================

[Config MultiHopPerformanceBaseline]
extends = QueueAwareTiebreakerValidation
description = "Multi-hop: Baseline GPSR (no tiebreaker), relays required"

# Reduce radio power to force multi-hop routing (source cannot reach destination directly)
*.host[*].wlan[*].radio.transmitter.power = 6.5mW  # Range ~280m, src-dest distance 450m

# Disable tiebreaker for baseline behavior
*.host[*].routing.enableDelayTiebreaker = false

[Config MultiHopPerformanceEnhanced]
extends = QueueAwareTiebreakerValidation
description = "Multi-hop: Queue-aware GPSR (with tiebreaker), relays required"

# Reduce radio power to force multi-hop routing
*.host[*].wlan[*].radio.transmitter.power = 6.5mW  # Range ~280m, src-dest distance 450m

# Enable tiebreaker (already enabled in base config, explicit for clarity)
*.host[*].routing.enableDelayTiebreaker = true
*.host[*].routing.enableQueueDelay = true

#=============================================================================
# BEACON SUPPRESSION TEST: Lower congestion to verify radio behavior
#=============================================================================

[Config BeaconSuppressionTest_50Percent]
extends = QueueAwareTiebreakerValidation
description = "Test with 50% link utilization (1 Mbps on 2 Mbps link)"

# Reduce congestion to 50% of link capacity
*.host[1].app[0].sendInterval = 0.008s      # 125 pkt/s × 1024B = 1.024 Mbps

[Config BeaconSuppressionTest_25Percent]
extends = QueueAwareTiebreakerValidation
description = "Test with 25% link utilization (0.5 Mbps on 2 Mbps link)"

# Reduce congestion to 25% of link capacity
*.host[1].app[0].sendInterval = 0.016s      # 62.5 pkt/s × 1024B = 0.512 Mbps

#=============================================================================
# CPU OFFLOAD CAPACITY VALIDATION (Phase 4)
#=============================================================================

[Config CpuOffloadBeaconValidation]
extends = QueueAwareTiebreakerValidation
description = "Validation: CPU offload capacity beaconing and neighbor table storage"
sim-time-limit = 20s

# CPU offload capacity parameters - heterogeneous per-node capacity
*.host[*].routing.cpuTotalHz = 2e9          # 2 GHz base CPU
*.host[*].routing.offloadShareMin = 0.2      # 20% minimum offload capacity
*.host[*].routing.offloadShareMax = 0.6      # 60% maximum offload capacity

# Keep beaconing active to observe CPU capacity exchange
*.host[*].routing.beaconInterval = 2s

# Disable traffic flows to focus on beacon validation
*.host[0].numApps = 0
*.host[1].numApps = 0
*.host[2].numApps = 0
*.host[3].numApps = 0

#=============================================================================
# OFFLOAD DECISION LOGGING (Phase 5: Step 1-2)
#=============================================================================

[Config OffloadDecisionLogging]
extends = CpuOffloadBeaconValidation
description = "Step 1-2: Log local vs offload decision estimates (no actual offloading yet)"
sim-time-limit = 40s

# Enable offload decision logging
*.host[*].routing.enableOffloadDecisions = true
*.host[*].routing.taskInputBits = 8192           # 1 KB task
*.host[*].routing.taskCyclesPerBit = 1000        # moderate complexity

# Re-enable test traffic from source to destination
*.host[0].numApps = 1
*.host[0].app[0].typename = "UdpBasicApp"
*.host[0].app[0].destAddresses = "host[3]"
*.host[0].app[0].destPort = 6001
*.host[0].app[0].messageLength = 500B
*.host[0].app[0].sendInterval = 2s               # Low rate to see individual decisions
*.host[0].app[0].startTime = 10s
*.host[0].app[0].stopTime = 35s

# Destination sink
*.host[3].numApps = 1
*.host[3].app[0].typename = "UdpSink"
*.host[3].app[0].localPort = 6001

# Add some congestion to Relay A (host[1]) to make offload decisions interesting
*.host[1].numApps = 1
*.host[1].app[0].typename = "UdpBasicApp"
*.host[1].app[0].destAddresses = "host[3]"
*.host[1].app[0].destPort = 6000
*.host[1].app[0].messageLength = 1024B
*.host[1].app[0].sendInterval = 0.008s           # ~1 Mbps background load
*.host[1].app[0].startTime = 6s
*.host[1].app[0].stopTime = 35s

*.host[3].app[1].typename = "UdpSink"
*.host[3].app[1].localPort = 6000
