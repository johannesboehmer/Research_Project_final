#
# Queue-Aware GPSR Tiebreaker - Validation Test
# Demonstrates queue-aware routing decisions when GPSR candidates are equidistant
#
# SPDX-License-Identifier: LGPL-3.0-or-later
#

[General]
network = DelayTiebreakerNetwork
result-dir = ../../results/delay_tiebreaker

#=============================================================================
# VALIDATION TEST: Hexagonal Topology with Differential Congestion
#=============================================================================

[Config QueueAwareTiebreakerValidation]
description = "Queue-aware tiebreaker validation: idle relay selected over congested relay"
sim-time-limit = 40s

# Network topology: 4 nodes (source, 2 relays, destination)
*.numHosts = 4

# Radio medium configuration - IEEE 802.11 Scalar (realistic MAC/PHY)
# No medium-level configuration needed (uses defaults)

# Wireless interface - IEEE 802.11e with full QoS/EDCA support
*.host[*].numWlanInterfaces = 1
*.host[*].wlan[0].typename = "Ieee80211Interface"
*.host[*].wlan[*].bitrate = 2Mbps

# MAC: Enable complete QoS stack (802.11e HCF/EDCA)
*.host[*].wlan[*].mac.typename = "Ieee80211Mac"
*.host[*].wlan[*].mac.qosStation = true

# QoS Classifier: Maps UserPriority tags to EDCA Access Categories
*.host[*].wlan[*].classifier.typename = "QosClassifier"

# EDCA with 4 access categories (automatically configured by qosStation=true)
# Configure queue for each access category
*.host[*].wlan[*].mac.hcf.edca.edcaf[*].queue.typename = "DropTailQueue"
*.host[*].wlan[*].mac.hcf.edca.edcaf[*].queue.packetCapacity = 100

# AC mapping (done automatically by QosClassifier based on UserPriority):
# AC_BK (Background): UP 1-2
# AC_BE (Best Effort): UP 0, 3  ← UDP data traffic (no UP tag = default 0)
# AC_VI (Video): UP 4-5
# AC_VO (Voice): UP 6-7 ← GPSR beacons (UP=7 set in code)

# Radio configuration
*.host[*].wlan[*].radio.typename = "Ieee80211ScalarRadio"
*.host[*].wlan[*].radio.transmitter.power = 20mW  # INCREASED to ensure all nodes can exchange beacons
*.host[*].wlan[*].radio.transmitter.bitrate = 2Mbps

# Stationary positions - HEXAGONAL layout for perfect equidistance
*.host[*].mobility.typename = "StationaryMobility"
*.host[*].mobility.initFromDisplayString = false

# Node positions:
# - Source at origin (0, 200)
# - Relay A at (150, 330) - CONGESTED with background traffic
# - Relay B at (150, 70) - IDLE, no background traffic
# - Destination at (450, 200) - Beyond source's 300m range, forces routing through relays
# 
# Both relays are exactly 326.956m from destination (perfectly equidistant)
*.host[0].mobility.initialX = 0m        # Source
*.host[0].mobility.initialY = 200m
*.host[0].mobility.initialZ = 0m

*.host[1].mobility.initialX = 150m      # Relay A - CONGESTED
*.host[1].mobility.initialY = 330m
*.host[1].mobility.initialZ = 0m

*.host[2].mobility.initialX = 150m      # Relay B - IDLE
*.host[2].mobility.initialY = 70m
*.host[2].mobility.initialZ = 0m

*.host[3].mobility.initialX = 450m      # Destination
*.host[3].mobility.initialY = 200m
*.host[3].mobility.initialZ = 0m

# IP address configuration
*.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/></config>")

# Routing protocol - use QueueGpsr via standard INET routing interface
*.host[*].routing.typename = "researchproject.routing.queuegpsr.QueueGpsr"

# QueueGpsr routing parameters - ENABLE queue-aware tiebreaker
*.host[*].routing.beaconInterval = 2s
*.host[*].routing.neighborValidityInterval = 30s
*.host[*].routing.enableDelayTiebreaker = true              # ENABLE tiebreaker
*.host[*].routing.distanceEqualityThreshold = 10m            # Tight threshold for validation
*.host[*].routing.delayEstimationFactor = 0.001s
*.host[*].routing.enableQueueDelay = true                   # RE-ENABLED with UDP/IP-level measurement
*.host[*].routing.displayBubbles = false

# Required module paths for MANET routing
*.host[*].routing.interfaceTableModule = "^.interfaceTable"
*.host[*].routing.routingTableModule = "^.ipv4.routingTable"
*.host[*].routing.networkProtocolModule = "^.ipv4.ip"
*.host[*].routing.outputInterface = "wlan0"

# Background congestion on Relay A (host[1])
# Moderate congestion: 183 pkt/s × 1024B = 1.50 Mbps (75% of 2 Mbps link)
# Creates measurable queue buildup for tiebreaker activation
# Starts at t=6s (after beacon propagation) to ensure neighbor discovery
*.host[1].numApps = 1
*.host[1].app[0].typename = "UdpBasicApp"
*.host[1].app[0].destAddresses = "host[3]"
*.host[1].app[0].destPort = 6000
*.host[1].app[0].messageLength = 1024B
# *.host[1].app[0].sendInterval = 0.005s   # 183 pkt/s = 1.50 Mbps

# *.host[1].app[0].sendInterval = 0.00546s   # 183 pkt/s = 1.50 Mbps
*.host[1].app[0].sendInterval = 0.005s
*.host[1].app[0].startTime = 6s              # Delayed start
*.host[1].app[0].stopTime = 35s

# Main test flow: Source → Destination
# Starts at t=10s after neighbor discovery and congestion buildup
*.host[0].numApps = 1
*.host[0].app[0].typename = "UdpBasicApp"
*.host[0].app[0].destAddresses = "host[3]"
*.host[0].app[0].destPort = 6001
*.host[0].app[0].messageLength = 500B
*.host[0].app[0].sendInterval = 0.1s          # 10 pkt/s test flow
*.host[0].app[0].startTime = 10s
*.host[0].app[0].stopTime = 35s

# Destination sink applications
*.host[3].numApps = 2
*.host[3].app[0].typename = "UdpSink"
*.host[3].app[0].localPort = 6000
*.host[3].app[1].typename = "UdpSink"
*.host[3].app[1].localPort = 6001

# Relay B stays idle (no applications)
*.host[2].numApps = 0

#=============================================================================
# BASELINE COMPARISON: Tiebreaker disabled (standard GPSR behavior)
#=============================================================================

[Config QueueAwareTiebreakerDisabled]
extends = QueueAwareTiebreakerValidation
description = "Baseline: tiebreaker disabled, random relay selection"

# Disable queue-aware tiebreaker (standard GPSR)
*.host[*].routing.enableDelayTiebreaker = false

#=============================================================================
# MULTI-HOP PERFORMANCE COMPARISON: Force relay usage for measurable impact
#=============================================================================

[Config MultiHopPerformanceBaseline]
extends = QueueAwareTiebreakerValidation
description = "Multi-hop: Baseline GPSR (no tiebreaker), relays required"

# Reduce radio power to force multi-hop routing (source cannot reach destination directly)
*.host[*].wlan[*].radio.transmitter.power = 6.5mW  # Range ~280m, src-dest distance 450m

# Disable tiebreaker for baseline behavior
*.host[*].routing.enableDelayTiebreaker = false

[Config MultiHopPerformanceEnhanced]
extends = QueueAwareTiebreakerValidation
description = "Multi-hop: Queue-aware GPSR (with tiebreaker), relays required"

# Reduce radio power to force multi-hop routing
*.host[*].wlan[*].radio.transmitter.power = 6.5mW  # Range ~280m, src-dest distance 450m

# Enable tiebreaker (already enabled in base config, explicit for clarity)
*.host[*].routing.enableDelayTiebreaker = true
*.host[*].routing.enableQueueDelay = true

#=============================================================================
# BEACON SUPPRESSION TEST: Lower congestion to verify radio behavior
#=============================================================================

[Config BeaconSuppressionTest_50Percent]
extends = QueueAwareTiebreakerValidation
description = "Test with 50% link utilization (1 Mbps on 2 Mbps link)"

# Reduce congestion to 50% of link capacity
*.host[1].app[0].sendInterval = 0.008s      # 125 pkt/s × 1024B = 1.024 Mbps

[Config BeaconSuppressionTest_25Percent]
extends = QueueAwareTiebreakerValidation
description = "Test with 25% link utilization (0.5 Mbps on 2 Mbps link)"

# Reduce congestion to 25% of link capacity
*.host[1].app[0].sendInterval = 0.016s      # 62.5 pkt/s × 1024B = 0.512 Mbps
